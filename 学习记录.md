# 学习记录
# 2024年8月4日

在处理Dal层返回值问题时意识到返回可空类型的问题。如：
```csharp
    public static UserBModel? DebugGetUserById(int id)
    {
        using var context = DbContextFactory.GetDbContext();
        return context.Users.Find(id)?.ToUserBModel();
    }

    public static UserBModel? GetUserById(int id)
    {
        using var context = DbContextFactory.GetDbContext();
        return context.Users.Find(id)?.ToPublicUserBModel();
    }

    public static List<UserBModel>? GetUserByUserNameAndPassword(string userName, string password)
    {
        using var context = DbContextFactory.GetDbContext();
        var users = context.Users
            .Where(user => user.UserName == userName && user.Password == password)
            .ToList();
        if (users == null)
        {
            return null;
        }
        return users.Select(user => user.ToUserBModel()).ToList();
    }
```

首先应确定一点：如返回值为集合类型，不要返回Null，至少返回一个空集合。理由是null值的语义更接近：应该有返回值，但发生了未知错误导致返回值消失；而空集合意味着没有返回值。(参考[Is it better to return null or empty collection?](https://stackoverflow.com/questions/1969993/is-it-better-to-return-null-or-empty-collection))

如返回值为对象类型，返回值是空值还是默认值引发了激烈争论，且公说公有理婆说婆有理，让我们来看看程序员们吵成什么样子：

([Should a retrieval method return 'null' or throw an exception when it can't produce the return value? [closed]](https://stackoverflow.com/questions/175532/should-a-retrieval-method-return-null-or-throw-an-exception-when-it-cant-prod))

首先被淘汰的方案是只要有Null就抛异常让上层的异常处理模块处理。原因是：异常仅在程序出现了“出现了非预期行为”时才应该被抛出。当然，大量抛异常会影响程序性能，不过这并没有被作为主要的原因，大概这群偏执的程序员们不在乎这个。但出于安全性考虑，你也不想前端传来无数非法参数导致你的日志被异常信息挤爆。

其次默认值方案被忽略。显而易见没人会给每个不同的对象安排一个不同的默认值，调用者会想杀人的（我tm怎么知道默认值是什么，我tm为什么要处理默认值?）

那全返回null如何？从程序安全性上讲，C#的Object?已经是null对象模式了，不必像C++一样担心空引用异常。从程序功能是来讲，上面给出的三个函数中DebugGetUserById与GetUserById的确可能返回空值，毕竟传入的id的确不一定有对应的数据。但这陷入了语义上的冲突：返回null究竟是数据库里没有这个数据，还是发生了未知错误导致返回值消失？虽然上层代码不关心报错原因，但上层代码肯定关心到底是没数据还是报错：没数据那就没数据一切正常，报错了赶快给同事打电话修bug!

那现在我们要做的事情就显得比较清晰：返回值要携带的信息需要多一些，既然如此，一个流行的优化方案油然而生：统一返回值对象。

由此得到了优化工作的第一步：

<!-- TODO #1 -->
1. 统一返回值类型，封装为唯一类型，其中不仅包括原有的返回数据，也包括结果是否成功的标识，以及错误信息等上可能需要的信息。(参考[【规范】SpringBoot接口返回结果及异常统一处理，这样封装才优雅](https://zhuanlan.zhihu.com/p/656464576))

# 2024年8月5日

上一次优化将返回值类型统一后，我们要先做一点小更新：

<!-- todo #2 -->
为DAL层添加日志。

然后来处理后续的三个问题：异步方法，DTO与上下文依赖注入。

<!-- todo #3 -->
异步操作可以避免阻塞线程，特别是对于数据库操作。可以使用 async 和 await 来改进性能。
```csharp
public static async Task<Result<List<UserBModel>>> DebugGetAllUsersAsync()
{
    using var context = DbContextFactory.GetDbContext();
    var users = await context.Users.ToListAsync();
    var userBModels = users
        .Select(user => user?.ToUserBModel())
        .Where(userBModel => userBModel != null)
        .ToList();
    
    return Result<List<UserBModel>>.Success(userBModels);
}
```

<!-- todo #4 -->
避免暴露数据库模型。
```csharp
public class UserDto
{
    public int Id { get; set; }
    public string UserName { get; set; }
    // other properties
}

public static async Task<Result<UserDto?>> DebugGetUserByIdAsync(int id)
{
    using var context = DbContextFactory.GetDbContext();
    try
    {
        var user = await context.Users.FindAsync(id);
        if (user == null) return Result<UserDto?>.Failure("User not found");

        var userDto = new UserDto
        {
            Id = user.Id,
            UserName = user.UserName,
            // map other properties
        };

        return Result<UserDto?>.Success(userDto);
    }
    catch (Exception ex)
    {
        // Log the exception
        return Result<UserDto?>.Failure(ex.Message);
    }
}
```
注：参考[那些年，我们见过的Java服务端乱象](https://zhuanlan.zhihu.com/p/76849437)的第四点。

在现有代码中，IPostDal、IPostDalFactory与仅有的一个实现ComprehensiveSectionPostDal已经实现了服务化的项目设计。你可以发现在API层试图从IPostDalFactory拿到PostDal时vscode提示你无法访问，成功完成了防呆防盗设计！接下来SectionDal与UserDal也要修改！

<!-- todo #5 -->
依赖注入可以提高代码的可测试性和可维护性。可以通过构造函数注入 DbContext。
```csharp
public class UserDal
{
    private readonly DbContext _context;

    public UserDal(DbContext context)
    {
        _context = context;
    }

    public async Task<Result<List<UserBModel>>> DebugGetAllUsersAsync()
    {
        var users = await _context.Users.ToListAsync();
        var userBModels = users
            .Select(user => user?.ToUserBModel())
            .Where(userBModel => userBModel != null)
            .ToList();
        
        return Result<List<UserBModel>>.Success(userBModels);
    }
}
```

注：EF Core 的 DbContext 是非线程安全的，它设计为短时间内使用的对象。在 Web 应用程序中，通常会将 DbContext 注册为作用域级服务（Scoped），以便每个请求有一个独立的 DbContext 实例。

在这里，DebugGetAllUsersAsync 方法是异步的，并且使用了 await 关键字来异步获取用户列表。由于 await 会释放当前线程，它会在线程池中分配一个新的线程来继续执行。这种方式通常不会导致多线程问题，因为每次调用 DebugGetAllUsersAsync 都会使用单个线程来处理 DbContext 实例。

具体需要添加的代码为：
```csharp
// 添加DbContext服务
builder.Services.AddDbContext<MyDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"))
);
```
注意增加配置文件。

# 2024年8月6日

尝试引入XML文档自动生成工具。

在C#代码中，输入“///"将自动在代码中添加XML文档注释；在.csproj文件中，添加“<GenerateDocumentationFile>true</GenerateDocumentationFile>”将在项目生成时于bin/Debug/netx.x下生成XML注释文件。同时代码提示中会增加对公共类型或成员缺少XML注释的警告。而从 XML 注释创建输出这一步，微软推荐了三个工具：DocFX、Sandcastle、Doxygen。见[接受 XML 文档输入的工具](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/xmldoc/)。

再参考[浅尝 API文档生成框架](https://www.cnblogs.com/memoyu/p/16896143.html)，迅速排除Sandcastle，剩余两者中首先考虑了DocFX，并在详细调研后发现：2022年11月Microsoft Learn不再使用DocFX作为工具，原因是Microsoft Learn转向了更动态的架构，而不再考虑静态站点生成。他们新搭建了一个组合层，该层将各种格式的数据资产组合在一起生成最终的html页面，DocFX以后只作为一个小工具用来从markdown内容中生成文档和html。其次，考虑到跨语言跨平台问题与类继承图、调用图的生成，最终排除DocFX决定采用Doxygen。

<!-- todo #6 -->

# 2024年8月7日

~~为项目引入doxygen。显然文档文件不应包含在仓库中，应尝试github托管页面。~~

上午开头，下午探索，晚上解决。已成功引入doxygen，并在github上托管了静态html文档。可喜可贺。

<!-- todo #9 -->
doxygen另有一个用于绘制继承图调用图等图片的绘图插件，应尝试引入。